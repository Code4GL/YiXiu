
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一修 || 03《高性能JavaScript》第三章 DOM编程</title>
    <meta name="author" content="一修">
    <meta name="description" content="前端工程师 ">
    <meta name="keywords" content="Flutter,ReactNative,JavaScript,HTML,前端工程师 ">
    <meta name="google-site-verification" content="CebvJgZgrgSeXhlE9sY0FBkDqdqUzZJGlCNzxn9raUU" />
    <meta name="baidu-site-verification" content="code-sDqiOZdqc3" />
    <link rel="icon" href="/images/avatar.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">一修</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>主页</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>归档</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>分类</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>标签</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>关于</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>一修</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">主页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">归档</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">分类</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">标签</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">关于</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>03《高性能JavaScript》第三章 DOM编程 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/12/23
        </span>

        
        <span class="category">
            <a href="/categories/JavaScript">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                JavaScript
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/高性能JavaScript" style=color:#ff7d73>
                    高性能JavaScript
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/原生JS" style=color:#00bcd4>
                    原生JS
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <p><img src="/images/javascript/highPerformanceJs/highPerformanceJs.jpg" alt="highPerformanceJs"></p>
<h2 id="3-1-浏览器中的DOM"><a href="#3-1-浏览器中的DOM" class="headerlink" title="3.1 浏览器中的DOM"></a>3.1 浏览器中的DOM</h2><p>文档对象模型（DOM）是一个独立于语言的，用于操作<code>XML</code>和<code>HTML</code>文档操作的程序接口（API）。在浏览器中，主要用来与<code>HTML</code>文档打交道，同样也用在Web程序中获取<code>XML</code>文档，并使用DOM API来访问文档中的数据。</p>
<h3 id="天生就慢"><a href="#天生就慢" class="headerlink" title="天生就慢"></a>天生就慢</h3><p>简单理解，两个相互独立的功能只要通过接口彼此连接，就会产生消耗。将DOM和JavaScript各自想象成一个岛屿，它们之间用收费桥梁连接，JavaScript每次访问DOM都要途径这座桥，并交纳过桥费。访问DOM次数越多，费用就越高。</p>
<blockquote>
<p>性能优化：尽可能减少过桥的次数，努力呆在JavaScript岛上。</p>
</blockquote>
<h2 id="3-2-访问与修改"><a href="#3-2-访问与修改" class="headerlink" title="3.2 访问与修改"></a>3.2 访问与修改</h2><ul>
<li>描述<br>访问DOM元素是有代价的，修改元素则更为昂贵，尤其对HTML集合循环操作。</li>
<li>原因<br>它会导致浏览器重新计算页面的几何变化。</li>
<li>反例</li>
</ul>
<pre><code class="JavaScript">// 这个函数每次循环该元素都被访问两次：一次读取innerHTML属性值，另一次是重写它。
function innerHTMLLoop() &#123;
    for (var count = 0; count &lt; 15000; count++) &#123;
        document.getElementById(&#39;here&#39;).innerHTML += &#39;a&#39;; 
    &#125;
&#125;</code></pre>
<ul>
<li>正例</li>
</ul>
<pre><code class="JavaScript">// 用局部变量存储修改中的内容，在循环结束后一次性写入。
function innerHTMLLoop2() &#123;
    var content = &#39;&#39;;
    for (var count = 0; count &lt; 15000; count++) &#123;
        content += &#39;a&#39;;
    &#125;
    document.getElementById(&#39;here&#39;).innerHTML += content;
&#125;</code></pre>
<h3 id="3-2-1-innerHTML对比DOM方法"><a href="#3-2-1-innerHTML对比DOM方法" class="headerlink" title="3.2.1 innerHTML对比DOM方法"></a>3.2.1 innerHTML对比DOM方法</h3><p>修改页面区域的最佳方案？<br><code>innerHTML</code>：非标准但支持良好；<br><code>DOM API</code>：类似<code>document.createElement()</code>原生DOM方法。<br>答案：性能相差无几。除开WebKit内核（Chrome和Safari）之外的所有浏览器中，<code>innerHTML</code>会更快一些。</p>
<blockquote>
<p>性能优化：如果对一个性能有着苛刻要求的操作中更新一大段HTML，推荐使用innerHTML，因为它在绝大部分浏览器中运行的更快。但对于大多数日常操作而言，没有太大的区别。</p>
</blockquote>
<h3 id="3-2-2-节点克隆"><a href="#3-2-2-节点克隆" class="headerlink" title="3.2.2 节点克隆"></a>3.2.2 节点克隆</h3><p>使用DOM方法更新页面内容的另一个途径是克隆已有元素，而不是创建新元素。即使用<code>element.cloneNode()</code>替代<code>document.createElement()</code>。</p>
<blockquote>
<p>性能优化：大多数浏览器中，节点克隆都更有效率，但效果也不是特别明显。</p>
</blockquote>
<h3 id="3-2-3-HTML集合"><a href="#3-2-3-HTML集合" class="headerlink" title="3.2.3 HTML集合"></a>3.2.3 HTML集合</h3><p>HTML集合是包含了DOM节点引用的类数组对象。HTML集以一种“假定实时态”实时存在，这意味着当底层文档对象更新时，它也会自动更新。</p>
<blockquote>
<p>注意：此集合是类似数组的列表，并非数组。但提供了<code>length</code>属性，以及以数字索引方式访问列表中的元素</p>
</blockquote>
<pre><code class="JavaScript">// 以下方法返回的就是HTML集合。
document.getElementsByName()
document.getElementsByClassName()
document.getElementsByTagName()
document.images // 页面中所有的&lt;img&gt;元素
document.links // 所有的&lt;a&gt;元素
document.forms // 所有表单
document.forms[0].elements // 页面中第一个表单的所有字段</code></pre>
<blockquote>
<p>低效根源：事实上，HTML集合一直与文档保持着连接，每次你需要最新信息时，都会重复执行查询的过程，哪怕是只获取集合中的元素个数（length）也是如此。</p>
</blockquote>
<h4 id="3-2-3-1-昂贵的集合"><a href="#3-2-3-1-昂贵的集合" class="headerlink" title="3.2.3.1 昂贵的集合"></a>3.2.3.1 昂贵的集合</h4><ul>
<li>描述<br>将集合复制到数组中，进行操作数组来代替操作集合。</li>
<li>原因<br>读取集合中的<code>length</code>比读取普通数组中的<code>length</code>要慢很多。</li>
<li>反例</li>
</ul>
<pre><code class="JavaScript">var coll = document.getElementsByTagName(&#39;div&#39;);
// 慢
function loopCollection() &#123;
    for (var count = 0; count &lt; coll.length; count++) &#123;

    &#125;
&#125;</code></pre>
<ul>
<li>正例</li>
</ul>
<pre><code class="JavaScript">function toArray(coll) &#123;
    for (var i = 0, a = [], len = coll.length; i &lt; len; i++) &#123;
        a[i] = coll[i];
    &#125;
    return a;
&#125;
var coll = document.getElementsByTagName(&#39;div&#39;);
var ar = toArray(coll);
// 快
function loopCopiedArray() &#123;
    for (var count = 0; count &lt; arr.length; count++) &#123;

    &#125;
&#125;</code></pre>
<p>多数情况下只需要遍历一个相对较小的集合，那么缓存<code>length</code>就够了。</p>
<pre><code class="JavaScript">// 此函数运行得与loopCopiedArray()一样快。
function loopCacheLengthCollection() &#123;
    var coll = document.getElementsByTagName(&#39;div&#39;),
    len = coll.length;
    for (var count = 0; count &lt; len; count++) &#123;

    &#125;
&#125;</code></pre>
<blockquote>
<p>注意：这会因为额外的步骤带来消耗，而且会多遍历一次集合，因此需要评估在特定条件下数组拷贝是否有帮助。</p>
</blockquote>
<h4 id="3-2-3-2-访问集合元素时使用局部变量"><a href="#3-2-3-2-访问集合元素时使用局部变量" class="headerlink" title="3.2.3.2 访问集合元素时使用局部变量"></a>3.2.3.2 访问集合元素时使用局部变量</h4><p>当遍历一个集合时，第一优化原则是把集合存储在局部变量中，并把<code>length</code>缓存在循环外部，然后食用局部变量替代这些需要多次读取的元素。</p>
<pre><code class="JavaScript">// 较慢
function collectionGlobal() &#123;
    var coll = document.getElementsByTagName(&#39;div&#39;),
    len = coll.length,
    name = &#39;&#39;;
    for (var count = 0; count &lt; len; count++) &#123;
        name = document.getElementsByTagName(&#39;div&#39;)[count].nodeName;
        name = document.getElementsByTagName(&#39;div&#39;)[count].nodeType;
        name = document.getElementsByTagName(&#39;div&#39;)[count].tagName;
    &#125;
    return name;
&#125;;
// 较快
function collectionLocal() &#123;
    var coll = document.getElementsByTagName(&#39;div&#39;),
    len = coll.length,
    name = &#39;&#39;;
    for (var count = 0; count &lt; len; count++) &#123;
        name = coll[count].nodeName;
        name = coll[count].nodeType;
        name = coll[count].tagName;
    &#125;
    return name; 
&#125;;
// 最快
function collectionNodesLocal() &#123;
    var coll = document.getElementsByTagName(&#39;div&#39;),
    len = coll.length,
    name = &#39;&#39;,
    el = null;
    for (var count = 0; count &lt; len; count++) &#123;
        el = coll[count];
        name = el.nodeName;
        name = el.nodeType;
        name = el.tagName;
    &#125;
    return name;
&#125;;</code></pre>
<h3 id="3-2-4-遍历DOM"><a href="#3-2-4-遍历DOM" class="headerlink" title="3.2.4 遍历DOM"></a>3.2.4 遍历DOM</h3><h4 id="3-2-4-1-获取DOM元素"><a href="#3-2-4-1-获取DOM元素" class="headerlink" title="3.2.4.1 获取DOM元素"></a>3.2.4.1 获取DOM元素</h4><p>你可以使用<code>childNodes</code>得到元素集合，或者用<code>nextSibling</code>来获取每个相邻元素。</p>
<blockquote>
<p>性能优化：不同浏览器中，这两种方法运行时间几乎相等。在性能要求极高时，在老版本IE中更推荐<code>nextSibling</code>方法来查找DOM节点。</p>
</blockquote>
<h4 id="3-2-4-2-元素节点"><a href="#3-2-4-2-元素节点" class="headerlink" title="3.2.4.2 元素节点"></a>3.2.4.2 元素节点</h4><p>DOM元素诸如<code>childNodes</code>、<code>firstChild</code>、<code>nextSibling</code>并不区分元素节点和其他类型节点。多数情况下我们只需要访问元素节点，因此可能需要检查和过滤掉非元素节点。这些类型检查和过滤其实是比必要的操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18236822-841abaafbe9e7c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="能区分元素节点和其他节点的DOM属性"></p>
<blockquote>
<p>性能优化：使用左边的属性代替右边，效率更快。</p>
</blockquote>
<h4 id="3-2-4-3-选择器API"><a href="#3-2-4-3-选择器API" class="headerlink" title="3.2.4.3 选择器API"></a>3.2.4.3 选择器API</h4><p>使用CSS选择器也是一种定位节点的便利途径，因为开发者都熟悉CSS。最新浏览器提供了一个名为<code>querySelectorAll()</code>的原生DOM方法，这比使用JavaScript和DOM来遍历查找元素要快很多。</p>
<pre><code class="JavaScript">// 使用querySelectorAll()
var elements = document.querySelectorAll(&#39;#menu a&#39;);
// 不使用querySelectorAll()
var elements = document.getElementById(&#39;menu&#39;).getElementsByTagName_r(&#39;a&#39;);</code></pre>
<p>如果要处理大量组合查询，使用<code>querySelectorAll()</code>会更有效率。</p>
<pre><code class="JavaScript">var errs = document.querySelectorAll(&#39;div.warning, div.notice&#39;);</code></pre>
<p>还可以使用另一个方法<code>querySelector()</code>来获取第一个匹配的节点。</p>
<blockquote>
<p>注意：使用之前应该先检查一下浏览器是否支持，如果不支持，也许应该把库升级到最新版本了。</p>
</blockquote>
<h2 id="3-3-重绘与重排"><a href="#3-3-重绘与重排" class="headerlink" title="3.3 重绘与重排"></a>3.3 重绘与重排</h2><p>浏览器下载完页面的所有组件：HTML标签、JavaScript、CSS、图片后，会解析并生成两个内部数据结构：<br><code>DOM树</code>：表示页面结构。DOM树中的每一个需要显示的节点在渲染中至少存在一个对应的节点，隐藏的DOM元素在渲染树中没有对应的节点；<br><code>渲染树</code>：表示DOM节点如何显示。渲染树中的节点被称为“帧”或“盒”。<br>一旦DOM树和渲染树构建完成，浏览器就开始绘制页面元素了。当DOM的变化影响了元素的几何属性（宽和高）时，浏览器就需要重新计算元素的集合属性，同样其他元素的几何属性和位置也会受到影响。</p>
<p>重排（reflow）：浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树的过程；<br>重绘（repaint）：完成重排后，浏览器会冲洗绘制受影响的部分到屏幕中的过程。</p>
<blockquote>
<p>性能优化：重绘和重排操作的代价都是昂贵的，它们会导致Web应用的UI反应迟钝。所以应尽可能减少这类操作的发送。</p>
</blockquote>
<h3 id="3-3-1-重排何时发生"><a href="#3-3-1-重排何时发生" class="headerlink" title="3.3.1 重排何时发生"></a>3.3.1 重排何时发生</h3><p>当页面布局和几何属性改变时就需要重排，以下情况会发生重排：</p>
<ol>
<li>添加或删除可见的DOM元素；</li>
<li>元素位置改变；</li>
<li>元素尺寸改变；</li>
<li>内容改变；</li>
<li>页面渲染器初始化；</li>
<li>浏览器窗口尺寸改变。</li>
</ol>
<h3 id="3-3-2-渲染树变化的排队与刷新"><a href="#3-3-2-渲染树变化的排队与刷新" class="headerlink" title="3.3.2 渲染树变化的排队与刷新"></a>3.3.2 渲染树变化的排队与刷新</h3><p>由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。但以下获取布局信息的操作会强制刷新队列：</p>
<pre><code class="JavaScript">offsetTop, offsetLeft, offsetWidth, offsetHeight
scrollTop, scrollLeft, scrollWidth, scrollHeight
clientTop, clientLeft, clientWidth, clientHeight
getComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle）</code></pre>
<blockquote>
<p>性能优化：应避免使用以上的属性修改样式。</p>
</blockquote>
<h3 id="3-3-3-最小化重绘和重排"><a href="#3-3-3-最小化重绘和重排" class="headerlink" title="3.3.3 最小化重绘和重排"></a>3.3.3 最小化重绘和重排</h3><h4 id="3-3-3-1-改变样式"><a href="#3-3-3-1-改变样式" class="headerlink" title="3.3.3.1 改变样式"></a>3.3.3.1 改变样式</h4><ul>
<li>描述<br>重排和重绘的代价可能非常昂贵，因此减少此类操作会提升性能。</li>
<li>反例</li>
</ul>
<pre><code class="JavaScript">var el = document.getElementById(&#39;mydiv&#39;);
el.style.borderLeft = &#39;1px&#39;;
el.style.borderRight = &#39;2px&#39;;
el.style.padding = &#39;5px&#39;;</code></pre>
<p>-正例</p>
<pre><code class="JavaScript">// 合并改变，一次处理。
var el = document.getElementById(&#39;mydiv&#39;);
el.style.cssText = &#39;border-left: 1px; border-right: 2px; padding: 5px;&#39;;
// 保留现有样式。
el.style.cssText += &#39;; border-left: 1px;&#39;;
// 修改样式名称，尽管可能带来轻微的性能影响，因为改变类时需要检查级联样式。
var el = document.getElementById(&#39;mydiv&#39;);
el.className = &#39;active&#39;;</code></pre>
<h4 id="3-3-3-2-批量修改DOM"><a href="#3-3-3-2-批量修改DOM" class="headerlink" title="3.3.3.2 批量修改DOM"></a>3.3.3.2 批量修改DOM</h4><p>通过以下步骤可以减少一系列DOM操作带来重绘和重排的次数：</p>
<ol>
<li>使元素脱离文档流（触发重排）；</li>
<li>对其引用多重改变；</li>
<li>把元素带回文档中（触发重排）。</li>
</ol>
<p>使DOM脱离文档的三种方法：</p>
<ol>
<li>影藏元素，修改应用，重新显示；</li>
<li>使用文档片段在当前DOM之外构建一个子树，再把它拷贝回文档中；</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。</li>
</ol>
<pre><code class="JavaScript">// 更新节点数据通用函数
function appendDataToElement(appendToElement, data) &#123;
    var a, li;
    for (var i = 0, max = data.length; i &lt; max; i++) &#123;
        a = document.createElement(&#39;a&#39;);
        a.href = data[i].url;
        a.appendChild(document.createTextNode(data[i].name));
        li = document.createElement(&#39;li&#39;);
        li.appendChild(a);
        appendToElement.appendChild(li); 
    &#125;
&#125;;
// 第一种方案
var ul = document.getElementById(&#39;mylist&#39;);
ul.style.display = &#39;none&#39;;
appendDataToElement(ul, data);
ul.style.display = &#39;block&#39;;
// 第二种方案
var fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
document.getElementById(&#39;mylist&#39;).appendChild(fragment);
// 第三种方案
var old = document.getElementById(&#39;mylist&#39;);
var clone = old.cloneNode(true);
appendDataToElement(clone, data);
old.parentNode.replaceChild(clone, old);</code></pre>
<blockquote>
<p>性能优化：推荐尽可能使用第二种方案：文档片段。因为它们所产生的DOM和重排次数最少。</p>
</blockquote>
<h3 id="3-3-4-缓存布局信息"><a href="#3-3-4-缓存布局信息" class="headerlink" title="3.3.4 缓存布局信息"></a>3.3.4 缓存布局信息</h3><ul>
<li>描述<br>最好的做法是尽量减少布局信息的获取次数，获取后把它赋值给局部变量，然后再操作局部变量。</li>
<li>原因<br>当你查询布局信息时，浏览器会返回最新值，会刷新队列并应用所有变更。</li>
<li>反例</li>
</ul>
<pre><code class="JavaScript">// 低效的
myElement.style.left = 1 + myElement.offsetLeft + &#39;px&#39;;
myElement.style.top = 1 + myElement.offsetTop + &#39;px&#39;;
if (myElement.offsetLeft &gt;= 500) &#123;
    stopAnimation();
&#125;</code></pre>
<ul>
<li>正例</li>
</ul>
<pre><code class="JavaScript">current++
myElement.style.left = current + &#39;px&#39;;
myElement.style.top = current + &#39;px&#39;;
if (current &gt;= 500) &#123; 
    stopAnimation();
&#125;</code></pre>
<h3 id="3-3-5-让元素脱离动画流"><a href="#3-3-5-让元素脱离动画流" class="headerlink" title="3.3.5 让元素脱离动画流"></a>3.3.5 让元素脱离动画流</h3><p>用展开/折叠的方式来显示和影藏部分页面是一种常见的交互模式。它通常包括展开区域的几何动画，并将页面其他部分推向下方。<br>使用以下步骤可以避免页面中大部分重排：</p>
<ol>
<li>使用绝对位置定位页面上的动画元素，将其脱离文档流；</li>
<li>让元素动起来。当它扩大时覆盖部分页面。但是这只是页面的一个小区域重绘过程，不会产生重排和重绘页面的大部分内容；</li>
<li>当动画结束时回复定位，从而只会下移一次文档的其他元素。</li>
</ol>
<h3 id="3-3-6-IE和-hover"><a href="#3-3-6-IE和-hover" class="headerlink" title="3.3.6 IE和:hover"></a>3.3.6 IE和:hover</h3><p>从IE 7开始，IE允许使用<code>:hover</code>这个CSS伪选择器。然而，当你有大量元素使用<code>:hover</code>，那么会降低响应速度。此问题在IE 8上更为明显。</p>
<blockquote>
<p>性能优化：在元素很多的情况下，比如表格，应该避免使用<code>:hover</code>来高亮显示鼠标所在行。</p>
</blockquote>
<h2 id="3-4-事件委托"><a href="#3-4-事件委托" class="headerlink" title="3.4 事件委托"></a>3.4 事件委托</h2><p>根据DOM标准，每个时间都要经历三个阶段：</p>
<ol>
<li>捕获；</li>
<li>到达目标；</li>
<li>冒泡。<br>事件委托只需要冒泡即可。使用时事件代理，只需要给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有时间。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/18236822-da4ed35aa134f0c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个DOM树的例子"></p>
<p>当用户点击了“menu #1”链接，点击事件首先被<code>&lt;a&gt;</code>元素收到。然后它沿着 DOM 树冒泡，被<code>&lt;li&gt;</code>元素收到，然后是<code>&lt;ul&gt;</code>，以此类推，一直到达文档的顶层直至<code>window</code>。这使得你可以添加一个事件处理器，来接收所有子节点产生的事件消息。<br>也许你想为图中的文档提供一个渐进增强的<code>Ajax</code>体验。</p>
<pre><code class="JavaScript">document.getElementById(&#39;menu&#39;).onclick = function(e) &#123;
    // 浏览器target
    e = e || window.event;
    var target = e.target || e.srcElement;
    var pageid, hrefparts;
    // 只关心hrefs，非链接点击则退出
    // exit the function on non-link clicks
    if (target.nodeName !== &#39;A&#39;) &#123;
        return;
    &#125;
    // 从链接中找到页面ID
    hrefparts = target.href.split(&#39;/&#39;);
    pageid = hrefparts[hrefparts.length - 1];
    pageid = pageid.replace(&#39;.html&#39;, &#39;&#39;); 
    // 更新页面
    ajaxRequest(&#39;xhr.php?page=&#39; + id, updatePageContents);
    // 浏览器组织默认行为并取消冒泡
    if (typeof e.preventDefault === &#39;function&#39;) &#123;
        e.preventDefault();
        e.stopPropagation();
    &#125; else &#123;
        e.returnValue = false;
        e.cancelBubble = true;
    &#125;
&#125;;</code></pre>
<p>如你所见，事件委托技术并不复杂，你只需检查事件是否来自你所预期的元素。如果去掉跨浏览器兼容部分，代码会更简洁。<br>跨浏览器兼容部分包括：</p>
<ol>
<li>访问事件对象，并判断事件源；</li>
<li>取消文档树中的冒泡（可选）；</li>
<li>组织默认动作（可选，但本例需要，因为需要捕获并阻止打开链接）。</li>
</ol>
<p><strong>欢迎大佬纠错指导，欢迎交流学习。</strong></p>
<blockquote>
<p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/Code4GL">https://github.com/Code4GL</a><br>公众号：code_everything<br>QQ：771841496<br>邮箱：<a href="mailto:&#x67;&#117;&#x61;&#x6e;&#x6c;&#105;&#x31;&#x39;&#57;&#x31;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;">&#x67;&#117;&#x61;&#x6e;&#x6c;&#105;&#x31;&#x39;&#57;&#x31;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;</a></p>
</blockquote>
<p><img src="/images/code_everything.jpg" alt="code_everything"></p>

    </div>

    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2021 一修
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @一修
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>